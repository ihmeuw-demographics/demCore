% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_lt.R
\name{agg_lt}
\alias{agg_lt}
\title{Aggregate life table(s) to less granular age groups}
\usage{
agg_lt(
  dt,
  id_cols,
  age_mapping,
  missing_dt_severity = "stop",
  drop_present_aggs = F
)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Life table  to be aggregated. Must include all columns in \code{id_cols}, and
at least two of 'qx', 'ax', and 'mx', or just 'qx'.}

\item{id_cols}{[\code{character()}]\cr
ID columns that uniquely identify each row of \code{dt}.}

\item{age_mapping}{[\code{data.table()}]\cr
Specification of intervals to aggregate to. Required columns are
'age_start' and 'age_end'. Use "Inf" as 'age_end' for terminal age group.
The age group intervals must be contiguous and cover the entire interval
specified in the input life tables \code{dt}.}

\item{missing_dt_severity}{[\code{character(1)}]\cr
How severe should the consequences of missing data that prevents
aggregation or scaling from occurring be? Can be either 'stop', 'warning',
'message', or 'none'. If not "stop", then only the possible aggregations or
scaling is done using the available data.}

\item{drop_present_aggs}{[\code{logical(1)}]\cr
Whether to drop aggregates (or overlapping intervals) that are already
present in \code{dt} before aggregating. Default is 'False' and the function
errors out.}
}
\value{
[\code{data.table()}]\cr Aggregated life table(s) with columns for all
\code{id_cols}. A column for 'qx' is always included, a column for 'ax' will
also be returned if two of 'qx', 'ax', and 'mx' are included in the input
\code{dt}. Will only return the age groups specified in \code{age_mapping}.
}
\description{
Aggregate life table(s) to less granular age groups using
standard life table aggregation functions of qx (and ax).
}
\details{
See the \href{https://ihmeuw-demographics.github.io/demCore/index.html}{references page}
for the formatted equations below.

This function works by aggregating the qx and ax life table parameters
separately. If only qx is included in \code{dt} than ax aggregation is not done.

\strong{qx aggregation:}

To explain how qx is aggregated it is useful to define a couple of different
events:
\deqn{A = \text{death between age } x \text{ and } x + n}
\deqn{A' = \text{survival between age } x \text{ and } x + n}
\deqn{B = \text{survival to age } x}

Now qx and px can be written in terms of events A and B.
\deqn{{}_{n}q_x = P(A | B)}
\deqn{{}_{n}p_x = P(A' | B)}

Now say there are multiple sub age-groups that make up the overall age group
between \eqn{x \text{ and } x + n}. The first sub age-group could be between
\eqn{x \text{ and } x + n_1} and the second between
\eqn{x + n_1 \text{ and } x + n}. So \eqn{n = n_1 + n_2}.

The overall px value can be written as a function of the sub age-group's px
values.
\deqn{P(A'|B) = P(A'_1|B_1) \cap P(A'_2|B_2) = P(A'_1|B_1) * P(A'_2|B_2)}

where:
\deqn{P(A'_1 | B_1) = \text{survival between age } x \text{ and } x + n_1
  \text{ given survival to age } x}
\deqn{P(A'_2 | B_2) = \text{survival between age } x + n_1 \text{ and } x + n
  \text{ given survival to age } x + n_1}

More generally if there are \eqn{A} age groups between age
\eqn{x \text{ and } x + n}, and \eqn{i} indexes each of the sub age
intervals then:
\deqn{{}_{n}p_x = \prod_{i=1}^{A} {}_{n_i}p_{x_i}}
\deqn{{}_{n}q_x = 1 - {}_{n}p_x}

\strong{ax aggregation:}

\eqn{{}_{n}a_x} is aggregated across age groups by aggregating the number of
person-years lived in each age group by those who died in the interval.

\deqn{{}_{n}a_x \cdot {}_{n}d_x = \text{person-years lived between age } x
  \text{ and } x + n \text{ by those who died in this age interval}}
where:
\deqn{{}_{n}a_x = \text{average years lived between age } x \text{ and }
  x + n \text{ by those who died in the age interval}}
\deqn{{}_{n}d_x = \text{number that died between age } x \text{ and } x + n}

Now say there are \eqn{A} age groups between age \eqn{x \text{ and } x + n},
and \eqn{i} indexes each of the sub age intervals. The total number of
person-years lived by those who died in the aggregate age group is a simple
sum of the number of person-years lived in each sub age interval. The
aggregate ax can then be solved for.
\deqn{{}_{n}a_x \cdot {}_{n}d_x = \sum_{i = 1}^{A} {}_{n_i}a_{x_i}
  \cdot {}_{n_i}d_{x_i}}
\deqn{{}_{n}a_x = \frac{\sum_{i = 1}^{A} {}_{n_i}a_{x_i}
  \cdot {}_{n_i}d_{x_i}}{\sum_{i = 1}^{A} {}_{n_i}d_{x_i}}}
}
\examples{
dt <- data.table::data.table(
  age_start = c(0:110),
  age_end = c(1:110, Inf),
  location = "Canada",
  qx = .2,
  ax = .5
)
id_cols = c("age_start", "age_end", "location")
dt <- agg_lt(
  dt = dt,
  id_cols = id_cols,
  age_mapping = data.table::data.table(
    age_start = seq(0, 110, 5),
    age_end = c(seq(5, 110, 5), Inf)
  )
)

dt <- agg_lt(
  dt = dt[, .SD, .SDcols = c(id_cols, "qx")],
  id_cols = id_cols,
  age_mapping = data.table::data.table(
    age_start = seq(0, 110, 5),
    age_end = c(seq(5, 110, 5), Inf)
  )
)
}
\seealso{
\code{\link[hierarchyUtils:agg]{hierarchyUtils::agg()}}
}
