% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_lt.R
\name{agg_lt}
\alias{agg_lt}
\title{Aggregate life table(s) to less granular age groups}
\usage{
agg_lt(
  dt,
  id_cols,
  age_mapping,
  missing_dt_severity = "stop",
  overlapping_dt_severity = "stop",
  present_agg_severity = "stop"
)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Life table  to be aggregated. Must include all columns in \code{id_cols}, and
at least two of 'qx', 'ax', and 'mx', or just 'qx'.}

\item{id_cols}{[\code{character()}]\cr
ID columns that uniquely identify each row of \code{dt}.}

\item{age_mapping}{[\code{data.table()}]\cr
Specification of intervals to aggregate to. Required columns are
'age_start' and 'age_end'. Use "Inf" as 'age_end' for terminal age group.
The age group intervals must be contiguous and cover the entire interval
specified in the input life tables \code{dt}.}

\item{missing_dt_severity}{[\code{character(1)}]\cr
How severe should the consequences of missing data that prevents
aggregation or scaling from occurring be? Can be either 'skip', 'stop',
'warning', 'message', or 'none'. If 'skip', the checks for missing data are
skipped. If not 'stop', then only the possible aggregations or scaling is
done using the available data.}

\item{overlapping_dt_severity}{[\code{character(1)}]\cr
When \code{collapse_interval_cols = TRUE}, how severe should the consequences of
overlapping intervals that change or prevent collapsing to the most
detailed common set of intervals be? Can be either 'skip', 'stop',
'warning', 'message', or 'none'. If not "stop", then overlapping intervals
will be dropped and the function continues.}

\item{present_agg_severity}{[\code{logical(1)}]\cr
How severe should the consequences of aggregate data (versus only the most
detailed level be)? Can be either 'skip', 'stop', 'warning', 'message',
or 'none'. If 'skip', then the data will be included in any aggregates
because the checks will be skipped. If anything else other then 'stop', the
data will be dropped rather than included in possible aggregations.
Whether to drop aggregates (or overlapping intervals) that are already
present in \code{dt} before aggregating. Default is 'False' and the function
errors out.}
}
\value{
[\code{data.table()}]\cr Aggregated life table(s) with columns for all
\code{id_cols}. A column for 'qx' is always included, a column for 'ax' will
also be returned if two of 'qx', 'ax', and 'mx' are included in the input
\code{dt}. Will only return the age groups specified in \code{age_mapping}.
}
\description{
Aggregate life table(s) to less granular age groups using
standard life table aggregation functions of qx (and ax).
}
\details{
See the \href{https://ihmeuw-demographics.github.io/demCore/index.html}{references page}
for the formatted equations below.

This function works by aggregating the qx and ax life table parameters
separately. If only qx is included in \code{dt} then ax aggregation is not done.

\strong{qx aggregation:}

To explain how qx is aggregated it is useful to define a couple of different
events:
\deqn{D = \text{death between age } x \text{ and } x + n}
\deqn{D' = \text{survival between age } x \text{ and } x + n}
\deqn{S = \text{survival to age } x}

Now qx and px can be written in terms of events D and S.
\deqn{{}_{n}q_x = P(D | S)}
\deqn{{}_{n}p_x = P(D' | S)}

Now say there are multiple sub age-groups that make up the overall age group
between \eqn{x \text{ and } x + n}. Let subscripts "1" and "2" indicate
values specific to the first and second sub age-groups and assume values with
no subscript apply to the original aggregate age group. The first sub
age-group could be between \eqn{x \text{ and } x + n_1} and the second
between \eqn{x + n_1 \text{ and } x + n_1 + n_2}, where \eqn{n_1 + n_2 = n}.

The overall px value can be written as a function of the sub age-group's px
values.
\deqn{P(D'|S) = P(D'_1|B_1) \cap P(D'_2|B_2) = P(D'_1|B_1) * P(D'_2|B_2)}

where:
\deqn{P(D'_1 | B_1) = \text{survival between age } x \text{ and } x + n_1
  \text{ given survival to age } x}
\deqn{P(D'_2 | B_2) = \text{survival between age } x + n_1 \text{ and } x + n
  \text{ given survival to age } x + n_1}

More generally if there are \eqn{A} age groups between age
\eqn{x \text{ and } x + n}, and \eqn{i} indexes each of the sub age
intervals then:
\deqn{{}_{n}p_x = \prod_{i=1}^{A} {}_{n_i}p_{x_i} =
  \prod_{i=1}^{A}(1 - {}_{n_i}q_{x_i})}
\deqn{{}_{n}q_x = 1 - {}_{n}p_x}

\strong{ax aggregation:}

\eqn{{}_{n}a_x} is aggregated across age groups by aggregating the number of
person-years lived in each age group by those who died in the interval.

\deqn{{}_{n}a_x \cdot {}_{n}d_x = \text{person-years lived between age } x
  \text{ and } x + n \text{ by those who died in this age interval}}
where:
\deqn{{}_{n}a_x = \text{average years lived between age } x \text{ and }
  x + n \text{ by those who died in the age interval}}
\deqn{{}_{n}d_x = \text{number that died between age } x \text{ and } x + n}

Now say there are \eqn{A} age groups between age \eqn{x \text{ and } x + n},
and \eqn{i} indexes each of the sub age intervals. The total number of
person-years lived by those who died in the aggregate age group is a simple
sum of the number of person-years lived in each sub age interval.
\deqn{{}_{n}a_x \cdot {}_{n}d_x = \sum_{i = 1}^{A}
  ((x_i - x) + {}_{n_i}a_{x_i}) \cdot {}_{n_i}d_{x_i}}
where:
\deqn{x_i - x = \text{ number of complete person years lived in the previous
  sub age intervals by someone who dies in sub age interval } i}

The aggregate ax can then be solved for.
\deqn{{}_{n}a_x = \frac{\sum_{i = 1}^{A} ((x_i - x) + {}_{n_i}a_{x_i})
  \cdot {}_{n_i}d_{x_i}}{\sum_{i = 1}^{A} {}_{n_i}d_{x_i}}}
}
\examples{
dt <- data.table::data.table(
  age_start = c(0:110),
  age_end = c(1:110, Inf),
  location = "Canada",
  qx = .2,
  ax = .5
)
id_cols = c("age_start", "age_end", "location")
dt <- agg_lt(
  dt = dt,
  id_cols = id_cols,
  age_mapping = data.table::data.table(
    age_start = seq(0, 105, 5),
    age_end = seq(5, 110, 5)
  )
)

dt <- agg_lt(
  dt = dt[, .SD, .SDcols = c(id_cols, "qx")],
  id_cols = id_cols,
  age_mapping = data.table::data.table(
    age_start = seq(0, 110, 5),
    age_end = c(seq(5, 110, 5), Inf)
  ),
  present_agg_severity = "none"
)
}
\seealso{
\code{\link[hierarchyUtils:agg]{hierarchyUtils::agg()}}
}
